# ğŸ”„ å‰åç«¯è”åŠ¨æ¶æ„

## æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†æè¿°äº†è´¨æŠ¼ç³»ç»Ÿçš„å‰åç«¯è”åŠ¨æ¶æ„ï¼ŒåŒ…æ‹¬æ•°æ®æµå‘ã€APIè®¾è®¡ã€é”™è¯¯å¤„ç†ã€æ€§èƒ½ä¼˜åŒ–ç­‰å…³é”®æŠ€æœ¯å®ç°ã€‚

## ç³»ç»Ÿäº¤äº’æµç¨‹

```mermaid
graph TB
    A[ç”¨æˆ·å‰ç«¯] --> B[RainbowKit é’±åŒ…è¿æ¥]
    B --> C[Next.js åº”ç”¨]
    C --> D[ethers.js/wagmi]
    D --> E[æ™ºèƒ½åˆçº¦]
    E --> F[åŒºå—é“¾ç½‘ç»œ]
    
    G[äº‹ä»¶ç›‘å¬æœåŠ¡] --> H[Supabase æ•°æ®åº“]
    F --> G
    H --> I[å®æ—¶æ•°æ®åŒæ­¥]
    I --> C
    
    C --> J[API è·¯ç”±]
    J --> H
    H --> K[æ•°æ®åˆ†ææœåŠ¡]
```

## 1. å‰ç«¯åˆ°åˆçº¦çš„æ•°æ®æµ

### ç”¨æˆ·æ“ä½œæµç¨‹
```typescript
// 1. ç”¨æˆ·è¿æ¥é’±åŒ… (å‰ç«¯)
const { connect } = useConnect();
await connect({ connector: metaMaskConnector });

// 2. è·å–åˆçº¦å®ä¾‹ (å‰ç«¯)
const contract = useContract({
  address: STAKE_CONTRACT_ADDRESS,
  abi: StakeContractABI,
  signerOrProvider: signer
});

// 3. æ‰§è¡Œè´¨æŠ¼æ“ä½œ (å‰ç«¯ â†’ åˆçº¦)
const { write: stake } = useContractWrite({
  address: STAKE_CONTRACT_ADDRESS,
  abi: StakeContractABI,
  functionName: 'stake',
  args: [poolId, amount],
  onSuccess: (data) => {
    // 4. äº¤æ˜“æˆåŠŸåæ›´æ–°æœ¬åœ°çŠ¶æ€
    updateUserBalance();
    // 5. è®°å½•äº¤æ˜“åˆ°æ•°æ®åº“
    recordTransaction(data.hash);
  }
});
```

## 2. åˆçº¦åˆ°æ•°æ®åº“çš„æ•°æ®æµ

### äº‹ä»¶ç›‘å¬å’Œæ•°æ®åŒæ­¥
```javascript
// services/event-listener.js
class EventListener {
  constructor() {
    this.contract = new ethers.Contract(
      STAKE_CONTRACT_ADDRESS,
      StakeContractABI,
      provider
    );
  }

  async startListening() {
    // ç›‘å¬è´¨æŠ¼äº‹ä»¶
    this.contract.on('Staked', async (user, poolId, amount, event) => {
      await this.syncStakeEvent({
        user,
        poolId: poolId.toNumber(),
        amount: ethers.utils.formatEther(amount),
        txHash: event.transactionHash,
        blockNumber: event.blockNumber
      });
    });

    // ç›‘å¬è§£è´¨æŠ¼äº‹ä»¶
    this.contract.on('Unstaked', async (user, poolId, amount, event) => {
      await this.syncUnstakeEvent({
        user,
        poolId: poolId.toNumber(),
        amount: ethers.utils.formatEther(amount),
        txHash: event.transactionHash,
        blockNumber: event.blockNumber
      });
    });
  }

  async syncStakeEvent(eventData) {
    // 1. æ›´æ–°äº¤æ˜“è®°å½•
    await supabase.from('stake_transactions').insert({
      wallet_address: eventData.user,
      pool_id: eventData.poolId,
      transaction_type: 'stake',
      amount: eventData.amount,
      tx_hash: eventData.txHash,
      block_number: eventData.blockNumber,
      status: 'confirmed'
    });

    // 2. æ›´æ–°ç”¨æˆ·æŒä»“
    await this.updateUserPosition(eventData.user, eventData.poolId);

    // 3. æ›´æ–°æ± å­ç»Ÿè®¡
    await this.updatePoolStats(eventData.poolId);
  }
}
```

## 3. æ•°æ®åº“åˆ°å‰ç«¯çš„æ•°æ®æµ

### å®æ—¶æ•°æ®è·å–
```typescript
// hooks/useStakeData.ts
export const useStakeData = (walletAddress: string) => {
  const [userData, setUserData] = useState(null);
  const [poolStats, setPoolStats] = useState([]);

  // 1. è·å–ç”¨æˆ·æŒä»“æ•°æ®
  const fetchUserData = async () => {
    const { data } = await supabase
      .from('user_pool_positions')
      .select('*')
      .eq('wallet_address', walletAddress);
    
    setUserData(data);
  };

  // 2. è·å–æ± å­ç»Ÿè®¡æ•°æ®
  const fetchPoolStats = async () => {
    const { data } = await supabase
      .from('pool_stats')
      .select('*')
      .order('recorded_at', { ascending: false })
      .limit(1);
    
    setPoolStats(data);
  };

  // 3. å®æ—¶è®¢é˜…æ•°æ®å˜åŒ–
  useEffect(() => {
    const subscription = supabase
      .channel('stake_data')
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'user_pool_positions',
        filter: `wallet_address=eq.${walletAddress}`
      }, (payload) => {
        // å®æ—¶æ›´æ–°ç”¨æˆ·æ•°æ®
        fetchUserData();
      })
      .subscribe();

    return () => subscription.unsubscribe();
  }, [walletAddress]);

  return { userData, poolStats, fetchUserData, fetchPoolStats };
};
```

## 4. API è·¯ç”±è®¾è®¡

### Next.js API è·¯ç”±
```typescript
// pages/api/user/[address].ts
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { address } = req.query;

  try {
    // 1. è·å–é“¾ä¸Šæ•°æ®
    const contract = new ethers.Contract(STAKE_CONTRACT_ADDRESS, ABI, provider);
    const onChainData = await contract.getUserInfo(0, address);

    // 2. è·å–é“¾ä¸‹æ•°æ®
    const { data: offChainData } = await supabase
      .from('user_pool_positions')
      .select('*')
      .eq('wallet_address', address);

    // 3. åˆå¹¶æ•°æ®
    const combinedData = {
      onChain: {
        stakedAmount: ethers.utils.formatEther(onChainData.stAmount),
        pendingRewards: ethers.utils.formatEther(onChainData.pendingMetaNode)
      },
      offChain: offChainData,
      lastUpdated: new Date().toISOString()
    };

    res.status(200).json(combinedData);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch user data' });
  }
}

// pages/api/pools/stats.ts
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    // 1. è·å–æ‰€æœ‰æ± å­çš„é“¾ä¸Šæ•°æ®
    const poolsData = await Promise.all(
      Array.from({ length: POOL_COUNT }, async (_, i) => {
        const poolInfo = await contract.getPoolInfo(i);
        return {
          poolId: i,
          totalStaked: ethers.utils.formatEther(poolInfo.stTokenAmount),
          poolWeight: poolInfo.poolWeight.toNumber(),
          lastRewardBlock: poolInfo.lastRewardBlock.toNumber()
        };
      })
    );

    // 2. è·å–å†å²ç»Ÿè®¡æ•°æ®
    const { data: historicalData } = await supabase
      .from('pool_stats')
      .select('*')
      .order('recorded_at', { ascending: false })
      .limit(100);

    res.status(200).json({
      current: poolsData,
      historical: historicalData
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch pool stats' });
  }
}
```

## 5. æ•°æ®ä¸€è‡´æ€§ä¿è¯

### åŒå‘éªŒè¯æœºåˆ¶
```typescript
// services/data-consistency.ts
class DataConsistencyService {
  // å®šæœŸéªŒè¯é“¾ä¸Šé“¾ä¸‹æ•°æ®ä¸€è‡´æ€§
  async validateDataConsistency() {
    const users = await this.getAllActiveUsers();
    
    for (const user of users) {
      // 1. è·å–é“¾ä¸Šæ•°æ®
      const onChainData = await contract.getUserInfo(0, user.wallet_address);
      
      // 2. è·å–é“¾ä¸‹æ•°æ®
      const { data: offChainData } = await supabase
        .from('user_pool_positions')
        .select('*')
        .eq('wallet_address', user.wallet_address);

      // 3. æ¯”è¾ƒæ•°æ®
      const isConsistent = this.compareData(onChainData, offChainData[0]);
      
      if (!isConsistent) {
        // 4. æ•°æ®ä¸ä¸€è‡´æ—¶çš„å¤„ç†
        await this.handleInconsistency(user.wallet_address, onChainData, offChainData[0]);
      }
    }
  }

  async handleInconsistency(address: string, onChain: any, offChain: any) {
    // è®°å½•ä¸ä¸€è‡´æ—¥å¿—
    console.error(`Data inconsistency detected for ${address}`);
    
    // ä»¥é“¾ä¸Šæ•°æ®ä¸ºå‡†ï¼Œæ›´æ–°é“¾ä¸‹æ•°æ®
    await supabase
      .from('user_pool_positions')
      .update({
        staked_amount: ethers.utils.formatEther(onChain.stAmount),
        pending_rewards: ethers.utils.formatEther(onChain.pendingMetaNode),
        last_action_at: new Date().toISOString()
      })
      .eq('wallet_address', address);
  }
}
```

## 6. é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶

### å‰ç«¯é”™è¯¯å¤„ç†
```typescript
// hooks/useTransactionHandler.ts
export const useTransactionHandler = () => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleTransaction = async (txFunction: () => Promise<any>) => {
    setIsLoading(true);
    setError(null);

    try {
      // 1. æ‰§è¡Œäº¤æ˜“
      const tx = await txFunction();
      
      // 2. ç­‰å¾…ç¡®è®¤
      const receipt = await tx.wait();
      
      // 3. æ›´æ–°æœ¬åœ°çŠ¶æ€
      await updateLocalState(receipt);
      
      // 4. éªŒè¯æ•°æ®åŒæ­¥
      await verifyDataSync(receipt.transactionHash);
      
      return receipt;
    } catch (err: any) {
      // 5. é”™è¯¯å¤„ç†
      setError(err.message);
      throw err;
    } finally {
      setIsLoading(false);
    }
  };

  return { handleTransaction, isLoading, error };
};
```

## 7. å®é™…åº”ç”¨åœºæ™¯

### åœºæ™¯1ï¼šç”¨æˆ·è´¨æŠ¼æµç¨‹
```typescript
// å®Œæ•´çš„è´¨æŠ¼æµç¨‹ç¤ºä¾‹
const StakeFlow = () => {
  const { address } = useAccount();
  const { handleTransaction } = useTransactionHandler();
  const { userData, fetchUserData } = useStakeData(address);

  const handleStake = async (poolId: number, amount: string) => {
    try {
      // 1. å‰ç«¯éªŒè¯
      if (!address) throw new Error('è¯·å…ˆè¿æ¥é’±åŒ…');
      if (parseFloat(amount) <= 0) throw new Error('è´¨æŠ¼é‡‘é¢å¿…é¡»å¤§äº0');

      // 2. æ£€æŸ¥ä½™é¢
      const balance = await getTokenBalance(address);
      if (balance < parseFloat(amount)) throw new Error('ä½™é¢ä¸è¶³');

      // 3. æ‰§è¡Œè´¨æŠ¼äº¤æ˜“
      await handleTransaction(async () => {
        return await stake({ args: [poolId, parseEther(amount)] });
      });

      // 4. ç­‰å¾…æ•°æ®åŒæ­¥
      setTimeout(() => {
        fetchUserData();
      }, 3000);

      // 5. æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
      toast.success('è´¨æŠ¼æˆåŠŸï¼');
    } catch (error) {
      toast.error(error.message);
    }
  };

  return (
    <StakeForm onSubmit={handleStake} userData={userData} />
  );
};
```

### åœºæ™¯2ï¼šå®æ—¶æ”¶ç›Šè®¡ç®—
```typescript
// å®æ—¶æ”¶ç›Šè®¡ç®—å’Œæ˜¾ç¤º
const RewardsCalculator = () => {
  const { address } = useAccount();
  const [realTimeRewards, setRealTimeRewards] = useState('0');

  useEffect(() => {
    if (!address) return;

    // æ¯10ç§’æ›´æ–°ä¸€æ¬¡æ”¶ç›Š
    const interval = setInterval(async () => {
      try {
        // 1. è·å–é“¾ä¸Šå®æ—¶æ”¶ç›Š
        const pendingRewards = await contract.pendingMetaNode(0, address);
        
        // 2. è·å–å†å²æ”¶ç›Šæ•°æ®
        const { data: historicalRewards } = await supabase
          .from('reward_history')
          .select('*')
          .eq('wallet_address', address)
          .order('created_at', { ascending: false })
          .limit(1);

        // 3. è®¡ç®—æ€»æ”¶ç›Š
        const totalRewards = ethers.utils.formatEther(pendingRewards);
        setRealTimeRewards(totalRewards);

        // 4. æ›´æ–°æ•°æ®åº“ä¸­çš„å®æ—¶æ”¶ç›Š
        await supabase
          .from('user_pool_positions')
          .update({ 
            pending_rewards: totalRewards,
            last_updated: new Date().toISOString()
          })
          .eq('wallet_address', address);

      } catch (error) {
        console.error('Failed to update rewards:', error);
      }
    }, 10000);

    return () => clearInterval(interval);
  }, [address]);

  return (
    <div className="rewards-display">
      <h3>å®æ—¶æ”¶ç›Š</h3>
      <p>{realTimeRewards} META</p>
    </div>
  );
};
```

### åœºæ™¯3ï¼šæ•°æ®åˆ†æä»ªè¡¨æ¿
```typescript
// ç®¡ç†å‘˜æ•°æ®åˆ†æä»ªè¡¨æ¿
const AdminDashboard = () => {
  const [analytics, setAnalytics] = useState(null);

  useEffect(() => {
    const fetchAnalytics = async () => {
      // 1. è·å–æ± å­ç»Ÿè®¡
      const poolStats = await fetch('/api/pools/stats').then(r => r.json());
      
      // 2. è·å–ç”¨æˆ·ç»Ÿè®¡
      const userStats = await supabase
        .from('users')
        .select('count(*)')
        .single();

      // 3. è·å–äº¤æ˜“ç»Ÿè®¡
      const txStats = await supabase
        .from('stake_transactions')
        .select('transaction_type, amount')
        .gte('created_at', new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString());

      // 4. è®¡ç®—å…³é”®æŒ‡æ ‡
      const totalStaked = poolStats.current.reduce((sum, pool) => 
        sum + parseFloat(pool.totalStaked), 0);
      
      const dailyVolume = txStats.reduce((sum, tx) => 
        sum + parseFloat(tx.amount), 0);

      setAnalytics({
        totalStaked,
        dailyVolume,
        activeUsers: userStats.count,
        poolStats: poolStats.current
      });
    };

    fetchAnalytics();
    
    // æ¯åˆ†é’Ÿæ›´æ–°ä¸€æ¬¡
    const interval = setInterval(fetchAnalytics, 60000);
    return () => clearInterval(interval);
  }, []);

  return (
    <div className="admin-dashboard">
      <div className="metrics-grid">
        <MetricCard title="æ€»è´¨æŠ¼é‡" value={analytics?.totalStaked} />
        <MetricCard title="24häº¤æ˜“é‡" value={analytics?.dailyVolume} />
        <MetricCard title="æ´»è·ƒç”¨æˆ·" value={analytics?.activeUsers} />
      </div>
      <PoolStatsChart data={analytics?.poolStats} />
    </div>
  );
};
```

## 8. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### æ•°æ®ç¼“å­˜ç­–ç•¥
```typescript
// å¤šå±‚ç¼“å­˜ç­–ç•¥
class CacheManager {
  private memoryCache = new Map();
  private readonly CACHE_TTL = 30000; // 30ç§’

  async getCachedData(key: string, fetcher: () => Promise<any>) {
    // 1. æ£€æŸ¥å†…å­˜ç¼“å­˜
    const cached = this.memoryCache.get(key);
    if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
      return cached.data;
    }

    // 2. æ£€æŸ¥ localStorage ç¼“å­˜
    const localCached = localStorage.getItem(key);
    if (localCached) {
      const parsed = JSON.parse(localCached);
      if (Date.now() - parsed.timestamp < this.CACHE_TTL * 2) {
        this.memoryCache.set(key, parsed);
        return parsed.data;
      }
    }

    // 3. è·å–æ–°æ•°æ®
    const freshData = await fetcher();
    const cacheEntry = {
      data: freshData,
      timestamp: Date.now()
    };

    // 4. æ›´æ–°ç¼“å­˜
    this.memoryCache.set(key, cacheEntry);
    localStorage.setItem(key, JSON.stringify(cacheEntry));

    return freshData;
  }
}

// ä½¿ç”¨ç¼“å­˜çš„æ•°æ®è·å–
const useOptimizedStakeData = (address: string) => {
  const cacheManager = new CacheManager();
  
  const fetchUserData = useCallback(async () => {
    return await cacheManager.getCachedData(
      `user_data_${address}`,
      async () => {
        const { data } = await supabase
          .from('user_pool_positions')
          .select('*')
          .eq('wallet_address', address);
        return data;
      }
    );
  }, [address]);

  return { fetchUserData };
};
```

### æ‰¹é‡æ“ä½œä¼˜åŒ–
```typescript
// æ‰¹é‡æ•°æ®æ›´æ–°
class BatchProcessor {
  private updateQueue: any[] = [];
  private readonly BATCH_SIZE = 10;
  private readonly BATCH_DELAY = 1000;

  constructor() {
    // å®šæœŸå¤„ç†æ‰¹é‡æ›´æ–°
    setInterval(() => {
      this.processBatch();
    }, this.BATCH_DELAY);
  }

  addUpdate(update: any) {
    this.updateQueue.push(update);
    
    // å¦‚æœé˜Ÿåˆ—æ»¡äº†ï¼Œç«‹å³å¤„ç†
    if (this.updateQueue.length >= this.BATCH_SIZE) {
      this.processBatch();
    }
  }

  private async processBatch() {
    if (this.updateQueue.length === 0) return;

    const batch = this.updateQueue.splice(0, this.BATCH_SIZE);
    
    try {
      // æ‰¹é‡æ›´æ–°æ•°æ®åº“
      await supabase
        .from('user_pool_positions')
        .upsert(batch);
      
      console.log(`Processed batch of ${batch.length} updates`);
    } catch (error) {
      console.error('Batch processing failed:', error);
      // é‡æ–°åŠ å…¥é˜Ÿåˆ—é‡è¯•
      this.updateQueue.unshift(...batch);
    }
  }
}
```

## 9. ç›‘æ§å’Œæ—¥å¿—

### ç³»ç»Ÿç›‘æ§
```typescript
// ç³»ç»Ÿå¥åº·ç›‘æ§
class SystemMonitor {
  private metrics = {
    apiCalls: 0,
    errors: 0,
    responseTime: [],
    lastHealthCheck: Date.now()
  };

  async healthCheck() {
    try {
      // 1. æ£€æŸ¥æ•°æ®åº“è¿æ¥
      const { error: dbError } = await supabase
        .from('users')
        .select('count(*)')
        .limit(1);

      if (dbError) throw new Error('Database connection failed');

      // 2. æ£€æŸ¥åˆçº¦è¿æ¥
      const blockNumber = await provider.getBlockNumber();
      if (!blockNumber) throw new Error('Blockchain connection failed');

      // 3. æ£€æŸ¥æ•°æ®åŒæ­¥çŠ¶æ€
      const lastSync = await this.getLastSyncTime();
      const syncDelay = Date.now() - lastSync;
      
      if (syncDelay > 300000) { // 5åˆ†é’Ÿ
        throw new Error('Data sync is delayed');
      }

      this.metrics.lastHealthCheck = Date.now();
      return { status: 'healthy', metrics: this.metrics };
    } catch (error) {
      this.metrics.errors++;
      return { status: 'unhealthy', error: error.message };
    }
  }

  logApiCall(endpoint: string, duration: number) {
    this.metrics.apiCalls++;
    this.metrics.responseTime.push(duration);
    
    // ä¿æŒæœ€è¿‘100æ¬¡è°ƒç”¨çš„è®°å½•
    if (this.metrics.responseTime.length > 100) {
      this.metrics.responseTime.shift();
    }
  }
}
```

## 10. æœ€ä½³å®è·µæ€»ç»“

### å¼€å‘å»ºè®®

#### 1. æ•°æ®æµè®¾è®¡
- **å•å‘æ•°æ®æµ**ï¼šå‰ç«¯ â†’ åˆçº¦ â†’ äº‹ä»¶ â†’ æ•°æ®åº“ â†’ å‰ç«¯
- **é¿å…å¾ªç¯ä¾èµ–**ï¼šç¡®ä¿æ•°æ®æµå‘æ¸…æ™°ï¼Œé¿å…æ•°æ®ç«äº‰
- **äº‹ä»¶é©±åŠ¨æ¶æ„**ï¼šä½¿ç”¨åŒºå—é“¾äº‹ä»¶ä½œä¸ºæ•°æ®åŒæ­¥çš„è§¦å‘å™¨

#### 2. é”™è¯¯å¤„ç†
- **åˆ†å±‚é”™è¯¯å¤„ç†**ï¼šç½‘ç»œå±‚ã€ä¸šåŠ¡å±‚ã€UIå±‚åˆ†åˆ«å¤„ç†å¯¹åº”é”™è¯¯
- **ä¼˜é›…é™çº§**ï¼šé“¾ä¸Šæ•°æ®ä¸å¯ç”¨æ—¶ä½¿ç”¨ç¼“å­˜æ•°æ®
- **ç”¨æˆ·å‹å¥½æç¤º**ï¼šå°†æŠ€æœ¯é”™è¯¯è½¬æ¢ä¸ºç”¨æˆ·å¯ç†è§£çš„æç¤º

#### 3. æ€§èƒ½ä¼˜åŒ–
- **åˆç†ç¼“å­˜ç­–ç•¥**ï¼šå¤šå±‚ç¼“å­˜ï¼Œé¿å…é‡å¤è¯·æ±‚
- **æ‰¹é‡å¤„ç†**ï¼šåˆå¹¶å¤šä¸ªæ•°æ®æ›´æ–°æ“ä½œ
- **æ‡’åŠ è½½**ï¼šæŒ‰éœ€åŠ è½½æ•°æ®å’Œç»„ä»¶

#### 4. å®‰å…¨è€ƒè™‘
- **åŒé‡éªŒè¯**ï¼šå‰ç«¯éªŒè¯ + åˆçº¦éªŒè¯
- **ç”¨æˆ·ç¡®è®¤**ï¼šæ•æ„Ÿæ“ä½œéœ€è¦ç”¨æˆ·æ˜ç¡®ç¡®è®¤
- **æ•°æ®ä¸€è‡´æ€§**ï¼šå®šæœŸæ£€æŸ¥é“¾ä¸Šé“¾ä¸‹æ•°æ®ä¸€è‡´æ€§

#### 5. ç”¨æˆ·ä½“éªŒ
- **å®æ—¶åé¦ˆ**ï¼šåŠæ—¶æ˜¾ç¤ºæ“ä½œçŠ¶æ€å’Œç»“æœ
- **åŠ è½½æŒ‡ç¤º**ï¼šé•¿æ—¶é—´æ“ä½œæ˜¾ç¤ºè¿›åº¦
- **ç¦»çº¿å¤„ç†**ï¼šç½‘ç»œå¼‚å¸¸æ—¶çš„ä¼˜é›…å¤„ç†

## æŠ€æœ¯æ ˆæ€»ç»“

### å‰ç«¯æŠ€æœ¯æ ˆ
- **æ¡†æ¶**ï¼šNext.js 13+ (App Router)
- **çŠ¶æ€ç®¡ç†**ï¼šZustand / Redux Toolkit
- **Web3é›†æˆ**ï¼šwagmi + RainbowKit
- **UIç»„ä»¶**ï¼šTailwind CSS + Headless UI
- **å›¾è¡¨åº“**ï¼šChart.js / Recharts

### åç«¯æŠ€æœ¯æ ˆ
- **æ•°æ®åº“**ï¼šSupabase (PostgreSQL)
- **API**ï¼šNext.js API Routes
- **äº‹ä»¶ç›‘å¬**ï¼šethers.js Event Listeners
- **ç¼“å­˜**ï¼šRedis (å¯é€‰)
- **ç›‘æ§**ï¼šè‡ªå®šä¹‰ç›‘æ§ç³»ç»Ÿ

### åŒºå—é“¾æŠ€æœ¯æ ˆ
- **æ™ºèƒ½åˆçº¦**ï¼šSolidity
- **å¼€å‘æ¡†æ¶**ï¼šHardhat
- **æµ‹è¯•æ¡†æ¶**ï¼šHardhat + Chai
- **ç½‘ç»œ**ï¼šEthereum / Polygon / BSC

è¿™ä¸ªæ¶æ„è®¾è®¡ç¡®ä¿äº†ç³»ç»Ÿçš„å¯æ‰©å±•æ€§ã€å¯ç»´æŠ¤æ€§å’Œç”¨æˆ·ä½“éªŒï¼Œä¸ºè´¨æŠ¼ç³»ç»Ÿæä¾›äº†å®Œæ•´çš„æŠ€æœ¯è§£å†³æ–¹æ¡ˆã€‚